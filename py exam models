from django.db import models
from student.models import Student
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.utils.text import slugify
from django.core.files.storage import default_storage
from datetime import timedelta
import os
import re
import uuid
from typing import Optional

def question_image_upload_path(instance, filename):
    """
    Dynamic upload path for question images.
    - Legacy mode: question_images/<course_name>/<filename>
    - Subject-wise mode: questions/<course_name>/<subject>/Q_<number>_<timestamp>.<ext>
    """
    # Sanitize helper
    def sanitize(value: str) -> str:
        value = re.sub(r'[^a-zA-Z0-9_]', '_', value or '')
        value = re.sub(r'_+', '_', value)
        return value.strip('_') or 'unknown'

    course_name = sanitize(getattr(getattr(instance, 'course', None), 'course_name', 'unknown_course'))

    # Prefer subject-wise directories when subject is present (and not General)
    subject_value = getattr(instance, 'subject', None)
    if subject_value and subject_value != 'General':
        # Ensure filename follows Q_<number>_<timestamp>.<ext> to avoid overwrites
        name, ext = os.path.splitext(filename)
        qnum = getattr(instance, 'question_number', None)
        from datetime import datetime
        ts = datetime.now().strftime('%Y%m%d%H%M%S')
        base = f"Q_{qnum}" if qnum else sanitize(name)
        safe_name = f"{base}_{ts}{ext or '.png'}"
        return os.path.join('questions', course_name, subject_value, safe_name)

    # Legacy fallback
    return os.path.join('question_images', course_name, filename)


# =====================
# Assignments (NEW)
# =====================
def assignment_file_upload_path(instance, filename):
    """
    Store under media/assignments/<assignment-slug>/ with a UUID suffix to prevent overwrite.
    questions.pdf and answers.pdf will be named consistently but still unique per upload.
    """
    # Resolve slug safely even if instance not saved yet
    slug_val = getattr(instance, 'slug', None) or getattr(getattr(instance, 'assignment', None), 'slug', '') or 'assignment'
    name, ext = os.path.splitext(filename or '')
    ext = ext.lower() if ext else '.pdf'
    unique = uuid.uuid4().hex
    # Try to preserve semantic name when possible
    base = 'file'
    try:
        if name:
            base = re.sub(r'[^a-zA-Z0-9_-]', '_', name)
    except Exception:
        pass
    return os.path.join('assignments', slug_val, f"{base}_{unique}{ext}")

# =====================
# Notes (NEW)
# =====================

def notes_path_fn(instance, filename):
    """
    Place uploads under media/notes/<slug>/<uuid>.pdf to avoid overwrites.
    """
    name, ext = os.path.splitext(filename or '')
    ext = (ext or '.pdf').lower()
    slug_val = getattr(instance, 'slug', None) or slugify(getattr(instance, 'title', '') or 'note') or 'note'
    unique = uuid.uuid4().hex
    safe_base = re.sub(r'[^a-zA-Z0-9_-]', '_', (name or 'file')) or 'file'
    return os.path.join('notes', slug_val, f"{safe_base}_{unique}{ext}")

def validate_pdf_file(value):
    """
    Validator to ensure the uploaded file is a PDF and under the configured max size.
    - Checks content_type if available
    - Checks magic bytes: file must start with %PDF-
    - Enforces max size via settings or defaults to 50MB
    """
    from django.conf import settings
    # Max size (bytes)
    max_mb = getattr(settings, 'MAX_NOTE_FILE_SIZE_MB', 50)
    max_bytes = max_mb * 1024 * 1024
    size = getattr(value, 'size', None)
    if size is not None and size > max_bytes:
        raise ValidationError(f"File too large. Max allowed size is {max_mb} MB.")
    # MIME type hint
    ctype = getattr(value, 'content_type', '') or ''
    if ctype and ctype not in ('application/pdf', 'application/x-pdf'):  # allow common variants
        # We'll still verify magic bytes below to be certain
        pass
    # Magic bytes check: read start
    try:
        pos = value.tell()
    except Exception:
        pos = None
    try:
        value.seek(0)
        head = value.read(5)
        if not (isinstance(head, (bytes, bytearray)) and head.startswith(b'%PDF-')):
            raise ValidationError('Invalid PDF file.')
    finally:
        try:
            if pos is not None:
                value.seek(pos)
        except Exception:
            # If cannot seek back, ignore
            pass

class Batch(models.Model):
    """
    Lightweight Batch model to support ManyToMany linkage for Notes
    without altering existing Course/Student schema which use string batches.
    """
    name = models.CharField(max_length=50, unique=True)

    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name

class Note(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(max_length=220, unique=True)
    description = models.TextField(blank=True, null=True)
    file = models.FileField(upload_to=notes_path_fn, validators=[validate_pdf_file])
    batches = models.ManyToManyField(Batch, related_name='notes')
    uploaded_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    uploaded_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-id']

    def __str__(self):
        return self.title

    def save(self, *args, **kwargs):
        # Ensure slug is set and unique on first save and when title changes
        if not self.slug:
            base = slugify(self.title or '') or 'note'
            candidate = base
            i = 1
            while Note.objects.filter(slug=candidate).exclude(pk=self.pk).exists():
                i += 1
                candidate = f"{base}-{i}"
            self.slug = candidate
        super().save(*args, **kwargs)


class Course(models.Model):
    course_name = models.CharField(max_length=50)
    question_number = models.PositiveIntegerField()
    total_marks = models.PositiveIntegerField()
    marks_per_question = models.PositiveIntegerField(default=1, help_text='Marks awarded per correct question')
    total_questions = models.PositiveIntegerField(default=0, help_text='Expected number of questions for PDF processing')
    duration_minutes = models.PositiveIntegerField(default=60)  # Duration in minutes
    # Global activation timestamp – when admin activates the test, this is set.
    # All students share a single countdown based on this time + duration_minutes.
    activated_at = models.DateTimeField(null=True, blank=True)
    negative_mark = models.BooleanField(default=False, verbose_name='Negative Mark')
    # Batch assignment to restrict which students can see/attend this test
    BATCH_CHOICES = (
        ('11th CET', '11th CET'),
        ('11th NEET', '11th NEET'),
        ('11th JEE', '11th JEE'),
        ('12th CET', '12th CET'),
        ('12th NEET', '12th NEET'),
        ('12th JEE', '12th JEE'),
        # Emergency batches
        ('11th Emergency 1', '11th Emergency 1'),
        ('11th Emergency 2', '11th Emergency 2'),
        ('12th Emergency 1', '12th Emergency 1'),
        ('12th Emergency 2', '12th Emergency 2'),
    )
    batch = models.CharField(max_length=20, choices=BATCH_CHOICES, default='11th CET')
    # New: comma-separated list of batches for multi-assignment (backward compatible with 'batch')
    batches = models.TextField(blank=True, null=True, help_text='Comma-separated batches for multi-assignment')

    STATUS_CHOICES = (
        ('draft', 'Draft'),
        ('active', 'Active'),
    )
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft')

    class Meta:
        ordering = ['-id']  # Latest courses first (descending order by ID)

    def __str__(self):
        return self.course_name

    def get_batches_list(self):
        """Return list of batches from the comma-separated 'batches' field, normalized.
        Includes the single 'batch' if 'batches' is empty.
        """
        if self.batches:
            items = [s.strip() for s in str(self.batches).split(',') if s and s.strip()]
            return items or ([self.batch] if self.batch else [])
        return [self.batch] if self.batch else []

class Question(models.Model):
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    marks = models.PositiveIntegerField()
    question = models.CharField(max_length=600)
    question_number = models.PositiveIntegerField(null=True, blank=True)  # Auto-incremented question number
    SUBJECT_CHOICES = (
        ('General', 'General'),
        ('Physics', 'Physics'),
        ('Chemistry', 'Chemistry'),
        ('Maths', 'Maths'),
        ('Biology', 'Biology'),
        ('Numericals', 'Numericals'),
    )
    subject = models.CharField(max_length=20, choices=SUBJECT_CHOICES, default='General')
    # New answer type support (backward compatible – default MCQ)
    ANSWER_TYPE_CHOICES = (
        ('MCQ', 'MCQ (single choice)'),
        ('NUMERIC', 'Numeric Input'),
        ('MULTISELECT', 'Multiple Select Options'),
    )
    answer_type = models.CharField(max_length=12, choices=ANSWER_TYPE_CHOICES, default='MCQ')
    # For NUMERIC questions: non-negative integer answer
    numeric_answer = models.PositiveIntegerField(null=True, blank=True)
    # For MULTISELECT questions: list of correct options like ["A","C"]
    try:
        from django.db.models import JSONField as BuiltinJSONField  # Django 3.1+
        JSONField = BuiltinJSONField
    except Exception:  # pragma: no cover
        from django.contrib.postgres.fields import JSONField  # type: ignore
    correct_options = JSONField(null=True, blank=True)
    option_a = models.CharField(max_length=255, default='Option A')
    option_b = models.CharField(max_length=255, default='Option B')
    option_c = models.CharField(max_length=255, default='Option C')
    option_d = models.CharField(max_length=255, default='Option D')
    correct_answer = models.CharField(
        max_length=1,
        choices=[('A','A'),('B','B'),('C','C'),('D','D')],
        default='A'
    )
    image = models.ImageField(upload_to=question_image_upload_path, null=True, blank=True)  # Optional image for question

    class Meta:
        ordering = ['subject', 'question_number', 'id']  # Order by subject, number, then by ID
        unique_together = (('course', 'subject', 'question_number'),)
        indexes = [
            models.Index(fields=['course', 'subject']),
        ]

    def __str__(self):
        subj = f"[{self.subject}] " if getattr(self, 'subject', None) else ''
        return f"{subj}Q{self.question_number or 'Manual'} - {self.course.course_name}"

class Result(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    exam = models.ForeignKey(Course, on_delete=models.CASCADE)
    marks = models.PositiveIntegerField()
    date = models.DateTimeField(auto_now=True)
    violation = models.BooleanField(default=False)

    class Meta:
        indexes = [
            models.Index(fields=['student', 'exam']),
        ]

class StudentAnswer(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    exam = models.ForeignKey(Course, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    selected_option = models.CharField(max_length=10, blank=True, null=True)  # A/B/C/D
    # New fields to support numeric and multi-select answers
    numeric_answer = models.PositiveIntegerField(null=True, blank=True)
    try:
        from django.db.models import JSONField as BuiltinJSONField  # Django 3.1+
        JSONField = BuiltinJSONField
    except Exception:  # pragma: no cover
        from django.contrib.postgres.fields import JSONField  # type: ignore
    selected_options = JSONField(null=True, blank=True)  # e.g., ["A","C"]
    answered_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = (('student', 'exam', 'question'),)
        indexes = [
            models.Index(fields=['student', 'exam']),
            models.Index(fields=['exam']),
        ]

    def __str__(self):
        return f"{self.student} - {self.exam} - Q{self.question}"

class QuestionTimeLog(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    start_time = models.DateTimeField()
    end_time = models.DateTimeField(null=True, blank=True)
    time_spent = models.DurationField(null=True, blank=True)

    class Meta:
        unique_together = (('student', 'question'),)

    def save(self, *args, **kwargs):
        # Accumulate time across multiple enter/exit cycles for a question
        if self.start_time is not None and self.end_time is not None:
            try:
                # When updating an existing row, self.time_spent already holds accumulated duration
                accumulated = self.time_spent or timedelta(0)
                delta = (self.end_time - self.start_time)
                # Only add positive deltas
                if delta.total_seconds() > 0:
                    self.time_spent = accumulated + delta
                else:
                    self.time_spent = accumulated
            except Exception:
                # Fallback to single delta if anything goes wrong
                self.time_spent = (self.end_time - self.start_time)
        super().save(*args, **kwargs)


# JSONField compatibility helper
try:
    from django.db.models import JSONField as BuiltinJSONField  # Django 3.1+
    JSONField = BuiltinJSONField
except Exception:  # pragma: no cover
    from django.contrib.postgres.fields import JSONField  # type: ignore


class Assignment(models.Model):
    name = models.CharField(max_length=200)
    slug = models.SlugField(max_length=220, unique=True)
    # Batches: reuse Course.BATCH_CHOICES for consistency; store M2M to a Batch-like model is not present,
    # so we will store as TextField CSV for now to avoid impacting legacy models, plus helper methods.
    # However, requirement asks for ManyToMany(Batch). If a Batch model exists elsewhere, we would link it.
    # In this codebase, batches live as strings in Course; so we mirror with a CSV while keeping API similar.
    batches_csv = models.TextField(blank=True, null=True, help_text='Comma-separated batches for this assignment')
    questions_pdf = models.FileField(upload_to=assignment_file_upload_path, blank=True, null=True)
    answers_pdf = models.FileField(upload_to=assignment_file_upload_path, blank=True, null=True)
    num_physics = models.PositiveIntegerField(default=0)
    num_chemistry = models.PositiveIntegerField(default=0)
    num_maths = models.PositiveIntegerField(default=0)
    num_biology = models.PositiveIntegerField(default=0)
    # Canonical correct answers after admin confirms parsing
    correct_answers = JSONField(null=True, blank=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-id']

    def __str__(self):
        return self.name

    def get_batches_list(self):
        if self.batches_csv:
            items = [s.strip() for s in str(self.batches_csv).split(',') if s and s.strip()]
            return items
        return []

    @property
    def total_questions(self) -> int:
        return int(self.num_physics or 0) + int(self.num_chemistry or 0) + int(self.num_maths or 0) + int(self.num_biology or 0)


class AssignmentAttempt(models.Model):
    assignment = models.ForeignKey(Assignment, on_delete=models.CASCADE, related_name='attempts')
    student = models.ForeignKey(Student, on_delete=models.CASCADE, related_name='assignment_attempts')
    attempt_no = models.PositiveIntegerField(default=1)
    responses = JSONField(null=True, blank=True)  # {"physics": ["A", ...], "chemistry": [...], ...}
    score_total = models.IntegerField(default=0)
    subject_breakdown = JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-id']
        unique_together = (('assignment', 'student', 'attempt_no'),)

    def __str__(self):
        return f"{self.student} - {self.assignment} - Attempt {self.attempt_no}"
